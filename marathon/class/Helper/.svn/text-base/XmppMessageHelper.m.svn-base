//
//  XmppMessageHelper.m
//  Match
//
//  Created by wangweiqing on 13-01-14.
//  Copyright 2013年 __MyCompanyName__. All rights reserved.
//

#import "XmppMessageHelper.h"

#define keyForArrayForReceivedMessage   @"ArrayForReceivedMessage"
#define keyForArrayForSendMessage       @"ArrayForSendMessage"

@implementation XmppMessageHelper

@synthesize arrayReceivedMessage;
@synthesize arraySendMessage;
@synthesize currentTime;

- (id)init {
    self = [super init];
    if (self) {
        
        self.arrayReceivedMessage = [NSMutableArray array];
        NSArray *arrayRcvMsg = [PersistenceHelper dataForKey:keyForArrayForReceivedMessage];
        if (arrayRcvMsg && [arrayRcvMsg isKindOfClass:[NSArray class]]) {
            [self.arrayReceivedMessage addObjectsFromArray:arrayRcvMsg];
        }
        
        self.arraySendMessage = [NSMutableArray array];
        NSString *cashFilePath = [XmppMessageHelper getMsgCashFileFullPath];
        NSMutableArray* msgStringArray = [NSMutableArray arrayWithContentsOfFile:cashFilePath];
        for (NSString* msgString in msgStringArray) {
            NSXMLElement *xmppMsg = [[NSXMLElement alloc] initWithXMLString:[NSString stringWithFormat:@"%@",msgString] error:nil];
            [arraySendMessage addObject:xmppMsg];
        }
    }
    return self;
}

#pragma mark - 消息发送

#pragma mark 文件全路径
+ (NSString*)getMsgCashFileFullPath {
	
    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask, YES);
    NSString *documentsDirectory = [paths objectAtIndex:0];
    NSString *fileName =@"Messages.log";
    NSString *cashFilePath = [documentsDirectory stringByAppendingPathComponent:fileName];
	
	return cashFilePath;
}

#pragma mark - 写入消息数组到文件
- (BOOL)saveSendMessageArrayToFile {
    BOOL isSucceed = NO;
    NSString *cashFilePath = [XmppMessageHelper getMsgCashFileFullPath];
    NSMutableArray* msgStringArray = [NSMutableArray arrayWithCapacity:0];
    for (NSXMLElement* msg in arraySendMessage) {
        [msgStringArray addObject:[NSString stringWithFormat:@"%@",msg]];
    }
    if (msgStringArray) {
        isSucceed = [msgStringArray writeToFile:cashFilePath atomically:YES];
    }
    return isSucceed;
}

#pragma mark - 是否有待发送消息
- (BOOL)hasToSendMessage {
    if (self.arraySendMessage && [self.arraySendMessage count] > 0) {
        return YES;
    } else {
        return NO;
    }
}

#pragma mark - 发送消息（同时保存消息到本地）
#pragma mark - 发送消息 简单格式
- (NSString*)sendMessageText:(NSString*)msgContent FromXmppJID:(NSString*)fromXmppJID ToXmppJID:(NSString*)toXmppJID clientMsgID:(NSString*)clientMsgID {
    if (msgContent && [msgContent length]>0) {
        NSXMLElement *xmppMessage = [self makeXmppMessage:msgContent FromXmppJID:fromXmppJID ToXmppJID:toXmppJID clientMsgID:clientMsgID];
        [self sendOneXmppMessage:xmppMessage];
        
        clientMsgID = [[xmppMessage attributeForName:@"client_msgid"] stringValue];
        return clientMsgID;
    }
    return nil;
}

#pragma mark - 发送消息 复杂格式
- (NSString*)sendXmppMessageText:(NSString*)msgContent FromXmppJID:(NSString*)fromXmppJID ToXmppJID:(NSString*)toXmppJID clientMsgID:(NSString*)clientMsgID ContentType:(NSString*)contentType PicUrl:(NSString*)picUrl ObjectID:(NSString*)objectID {
    if (msgContent && [msgContent length]>0) {
        NSXMLElement *xmppMessage = [self makeXmppMessage:msgContent FromXmppJID:fromXmppJID ToXmppJID:toXmppJID clientMsgID:clientMsgID ContentType:contentType PicUrl:picUrl ObjectID:objectID];
        [self sendOneXmppMessage:xmppMessage];
        
        clientMsgID = [[xmppMessage attributeForName:@"client_msgid"] stringValue];
        return clientMsgID;
    }
    return nil;
}

#pragma mark - 转换成XMPP消息，保存，并发送
- (void)sendOneXmppMessage:(NSXMLElement *)xmppMessage {
    if (xmppMessage) {
        //先添加到发送消息队列中
        [self addOneSendMessage:xmppMessage];
        //发送消息
        [self xmppSendMessage:xmppMessage];
    }
}

- (void)addOneSendMessage:(NSXMLElement *)xmppMessage {
    @synchronized(keyForArrayForSendMessage) {        
        [self.arraySendMessage addObject:xmppMessage];
//        [PersistenceHelper setData:arraySendMessage forKey:keyForArrayForSendMessage];
        [self saveSendMessageArrayToFile];
    }
}

#pragma mark - 移除一条消息
- (void)removeOneSendMessage:(NSXMLElement *)xmppMessage {
    @synchronized(keyForArrayForSendMessage) {
        if (xmppMessage) {
            NSMutableArray *delArray = [NSMutableArray array];
            for (int i = 0; i < [arraySendMessage count]; i++) {
                NSXMLElement *sendMessage = [arraySendMessage objectAtIndex:i];
                NSString *existMsgID = [[sendMessage attributeForName:@"client_msgid"] stringValue];
                NSString* deleteMsgID = [[xmppMessage attributeForName:@"client_msgid"] stringValue];
                if (existMsgID && [existMsgID length] > 0 && [existMsgID isEqualToString:deleteMsgID]) {
                    [delArray addObject:sendMessage];
                }
            }
            
            [arraySendMessage removeObjectsInArray:delArray];
//            [PersistenceHelper setData:arraySendMessage forKey:keyForArrayForSendMessage];
            [self saveSendMessageArrayToFile];
        }
    }    
}

#pragma mark - 移除一条消息，根据client_msgid
- (void)removeOneSendMessageByClientMsgid:(NSString *)deleteMsgID {
    @synchronized(keyForArrayForSendMessage) {
        if (deleteMsgID && [deleteMsgID length]>0) {
            NSMutableArray *delArray = [NSMutableArray array];
            for (int i = 0; i < [arraySendMessage count]; i++) {
                NSXMLElement *sendMessage = [arraySendMessage objectAtIndex:i];
                NSString *existMsgID = [[sendMessage attributeForName:@"client_msgid"] stringValue];
                if (existMsgID && [existMsgID length] > 0 && [existMsgID isEqualToString:deleteMsgID]) {
                    [delArray addObject:sendMessage];
                }
            }
            
            [arraySendMessage removeObjectsInArray:delArray];
            //            [PersistenceHelper setData:arraySendMessage forKey:keyForArrayForSendMessage];
            [self saveSendMessageArrayToFile];
        }
    }
}

#pragma mark - 清空所有消息
- (void)removeAllMessage {
    @synchronized(keyForArrayForSendMessage) {
        [self.arraySendMessage removeAllObjects];
//        [PersistenceHelper setData:arraySendMessage forKey:keyForArrayForSendMessage];
        [self saveSendMessageArrayToFile];
    }
}

#pragma mark - 调用XMPPStream重新发送消息，消息不保存
- (void)xmppReSendMessage:(NSXMLElement*)xmppMessage {
    @synchronized(keyForArrayForSendMessage)
    {
        if ([kXmppStream isConnected]) {
            XMPPElementReceipt* receiptPtr = nil;
            //发送消息
            [kXmppStream sendElement:xmppMessage andGetReceipt:&receiptPtr];
        }
    }
}

#pragma mark - 调用XMPPStream发送消息
- (void)xmppSendMessage:(NSXMLElement*)xmppMessage {
    @synchronized(keyForArrayForSendMessage)
    {
        if ([kXmppStream isConnected]) {
            XMPPElementReceipt* receiptPtr = nil;
            //发送消息
            [kXmppStream sendElement:xmppMessage andGetReceipt:&receiptPtr];
        }else {
            [arraySendMessage addObject:xmppMessage];
//            [PersistenceHelper setData:arrayReceivedMessage forKey:keyForArrayForReceivedMessage];
            [self saveSendMessageArrayToFile];
        }
    }
}
#pragma mark - 
#pragma mark - 生成一条Xmpp消息 简单格式
- (NSXMLElement*)makeXmppMessage:(NSString*)msgContent FromXmppJID:(NSString*)fromXmppJID ToXmppJID:(NSString*)toXmppJID clientMsgID:(NSString*)clientMsgID {
    if (msgContent.length > 0 && fromXmppJID.length > 0 && toXmppJID.length > 0) {
        
        //XMPPFramework主要是通过KissXML来生成XML文件
        //生成<body>文档
        NSXMLElement *body = [NSXMLElement elementWithName:@"body"];
        [body setStringValue:msgContent];
        
        //生成XML消息文档
        NSXMLElement *mes = [NSXMLElement elementWithName:@"message"];
        //消息类型
        [mes addAttributeWithName:@"type" stringValue:@"chat"];
        //发送给谁
        [mes addAttributeWithName:@"to" stringValue:toXmppJID];
        //由谁发送
        [mes addAttributeWithName:@"from" stringValue:fromXmppJID];
        //commit_time
        self.currentTime = [Utility getCurrentTime];
        [mes addAttributeWithName:@"commit_time" stringValue:currentTime];
        //client_msgid
        if (clientMsgID && [clientMsgID length]>0) {
            [mes addAttributeWithName:@"client_msgid" stringValue:clientMsgID];
            [mes addAttributeWithName:@"id" stringValue:clientMsgID];
        }else {
            CFUUIDRef msgid = CFUUIDCreate(nil);
            NSString *msgidString = [(NSString*)CFUUIDCreateString(nil, msgid) autorelease];
            CFRelease(msgid);
            [mes addAttributeWithName:@"client_msgid" stringValue:msgidString];
            [mes addAttributeWithName:@"id" stringValue:msgidString];
        }
        //组合
        [mes addChild:body];
        
        return mes;
    }
    
    return nil;
}

#pragma mark - 生成一条Xmpp消息 复杂格式
- (NSXMLElement*)makeXmppMessage:(NSString*)msgContent FromXmppJID:(NSString*)fromXmppJID ToXmppJID:(NSString*)toXmppJID clientMsgID:(NSString*)clientMsgID ContentType:(NSString*)contentType PicUrl:(NSString*)picUrl ObjectID:(NSString*)objectID {
    if (msgContent.length > 0 && fromXmppJID.length > 0 && toXmppJID.length > 0) {
        
        //XMPPFramework主要是通过KissXML来生成XML文件
        //生成<body>文档
        NSXMLElement *body = [NSXMLElement elementWithName:@"body"];
        [body setStringValue:msgContent];
        
        //生成XML消息文档
        NSXMLElement *mes = [NSXMLElement elementWithName:@"message"];
        //消息类型
        [mes addAttributeWithName:@"type" stringValue:@"chat"];
        //发送给谁
        [mes addAttributeWithName:@"to" stringValue:toXmppJID];
        //由谁发送
        [mes addAttributeWithName:@"from" stringValue:fromXmppJID];
        //commit_time
        self.currentTime = [Utility getCurrentTime];
        [mes addAttributeWithName:@"commit_time" stringValue:currentTime];
        //client_msgid
        if (clientMsgID && [clientMsgID length]>0) {
            [mes addAttributeWithName:@"client_msgid" stringValue:clientMsgID];
            [mes addAttributeWithName:@"id" stringValue:clientMsgID];
        }else {
            CFUUIDRef msgid = CFUUIDCreate(nil);
            NSString *msgidString = [(NSString*)CFUUIDCreateString(nil, msgid) autorelease];
            CFRelease(msgid);
            [mes addAttributeWithName:@"client_msgid" stringValue:msgidString];
            [mes addAttributeWithName:@"id" stringValue:msgidString];
        }
        
        //yijian域
        NSXMLElement *yijian = [NSXMLElement elementWithName:@"yijian"];
        //
        [yijian addAttributeWithName:@"xmlns" stringValue:@"yijian.com"];
        //内容类型
        [yijian addAttributeWithName:@"type" stringValue:contentType];
        //内容id
        [yijian addAttributeWithName:@"id" stringValue:objectID];
        //图片、礼物等的URL
        [yijian addAttributeWithName:@"url" stringValue:picUrl];
        
        //组合
        [mes addChild:body];
        [mes addChild:yijian];
        
        return mes;
    }
    
    return nil;
}

#pragma mark - 消息接收
#pragma mark - 是否有未读消息
- (BOOL)haveReceivedMessage {
    NSInteger msgCount = [self getAllRcvMsgCount];
    if (msgCount > 0) {
        return YES;
    }
    return NO;
}

#pragma mark XmppMessageDelegate
-(void)xmppNewMessageReceived:(NSDictionary *)messageDict {
    @synchronized(keyForArrayForReceivedMessage)
    {
        if (arrayReceivedMessage) {
            if ([arrayReceivedMessage count]>0) {
                [arrayReceivedMessage insertObject:messageDict atIndex:0];
            }else {
                [arrayReceivedMessage addObject:messageDict];
            }
            [PersistenceHelper setData:arrayReceivedMessage forKey:keyForArrayForReceivedMessage];
        }
    }
    //接收新消息的通知
    [[NSNotificationCenter defaultCenter] postNotificationOnMainThreadName:kEventHaveNewMessage object:nil];

    //显示新消息提示通知
    NSString* friendJid = [[messageDict objForKey:@"sender"] stringValue];
    NSDictionary* objectDict = [NSDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithInt:1], @"add", friendJid, @"jid", nil];
    [[NSNotificationCenter defaultCenter] postNotificationOnMainThreadName:kEventShowMessageTip object:objectDict];
}

- (NSInteger)getAllRcvMsgCount {
    return [arrayReceivedMessage count];
}

#pragma mark -
#pragma mark - 获取特定用户的未读消息数量
- (NSInteger)getRcvMsgCountByJID:(NSString*)fromXmppJID {
    NSInteger msgCount = 0;
    if (fromXmppJID && [fromXmppJID length]>0) {
        for (NSDictionary* dict in arrayReceivedMessage) {
            NSString* existJID = [dict objForKey:@"sender"];
            if (existJID && [existJID isEqualToString:fromXmppJID]) {
                msgCount++;
            }
        }
    }
    
    return msgCount;
}

#pragma mark -
#pragma mark - 获取特定用户的未读消息
- (NSMutableArray*)getRcvMsgByJID:(NSString*)fromXmppJID {
    NSMutableArray* rcvMsgArray = [[NSMutableArray alloc] initWithCapacity:0];
    if (fromXmppJID && [fromXmppJID length]>0) {
        for (NSDictionary* dict in arrayReceivedMessage) {
            NSString* existJID = [dict objForKey:@"sender"];
            if (existJID && [existJID isEqualToString:fromXmppJID]) {
                [rcvMsgArray addObject:dict];
            }
        }
    }
    
    return [rcvMsgArray autorelease];
}

#pragma mark -
#pragma mark - 清除特定用户的未读消息
- (void)cleanRcvMsgByJID:(NSString*)fromXmppJID {
    @synchronized(keyForArrayForReceivedMessage)
    {
        if (fromXmppJID && [fromXmppJID length]>0) {
            NSMutableArray *removeArray = [NSMutableArray arrayWithCapacity:0];
            for (NSDictionary* dict in arrayReceivedMessage) {
                NSString* existJID = [dict objForKey:@"sender"];
                if (existJID && [existJID isEqualToString:fromXmppJID]) {
                    [removeArray addObject:dict];
                }
            }
            
            if (removeArray && [removeArray count]>0) {
                [arrayReceivedMessage removeObjectsInArray:removeArray];
                [PersistenceHelper setData:arrayReceivedMessage forKey:keyForArrayForReceivedMessage];
            }
        }
    }
}

#pragma mark -
#pragma mark - 获取特定用户的最后一条未读消息
- (NSDictionary*)getLastRcvMsgByJID:(NSString*)fromXmppJID {
    if (fromXmppJID && [fromXmppJID length]>0) {        
        for (int n=0;n<[arrayReceivedMessage count];n++) {
            NSDictionary* lastMsgDict = [arrayReceivedMessage objectAtIndex:n];
            NSString* existJID = [lastMsgDict objForKey:@"sender"];
            if (existJID && [existJID isEqualToString:fromXmppJID]) {
                return lastMsgDict;
            }
        }
    }
    
    return nil;
}

#pragma mark - 清除无效消息
- (void)cleanRcvMsgArray {
    @synchronized(keyForArrayForReceivedMessage)
    {
        NSMutableArray *removeArray = [NSMutableArray arrayWithCapacity:0];
        for (NSDictionary* dict in arrayReceivedMessage) {
            NSString* toFindJID = [dict objForKey:@"sender"];
            BOOL isFromFriend = NO;
            
            NSArray* allFriendsArray = [PersistenceHelper dataForKey:FriendsArrayKey];
            if (allFriendsArray && [allFriendsArray count]>0) {
                for (NSDictionary* friendDict in allFriendsArray) {
                    NSString* existJID = [dict objForKey:@"jid"];
                    if (toFindJID && [toFindJID isEqualToString:existJID]) {
                        isFromFriend = YES;
                        break;
                    }
                }
                
                if (NO == isFromFriend) {
                    [removeArray addObject:dict];
                }
            }
        }
        
        if (removeArray && [removeArray count]>0) {
            [arrayReceivedMessage removeObjectsInArray:removeArray];
            [PersistenceHelper setData:arrayReceivedMessage forKey:keyForArrayForReceivedMessage];
        }
    }
}

- (void)dealloc {
    
    
    [PersistenceHelper setData:arrayReceivedMessage forKey:keyForArrayForReceivedMessage];
    
//    [PersistenceHelper setData:arraySendMessage forKey:keyForArrayForSendMessage];
    [self saveSendMessageArrayToFile];
    
    self.currentTime = nil;
    self.arraySendMessage   = nil;
    self.arrayReceivedMessage   = nil;
    [super dealloc];
}

@end
